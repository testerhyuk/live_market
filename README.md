# 📌 게시판 프로젝트 기술 정리

## ✅ 프로젝트 개요

- **목표**: 중고 거래 서비스 - 대규모 게시판 서비스를 MSA 기반 멀티모듈로 구현
- **기획 의도**
  - 중고 거래 서비스에서는 사진만으로 상품의 상태를 체크할 수 있음
  - 하지만, 사진을 찍을 때의 각도나 빛 반사 여부에 따라 실물과는 괴리가 있을 수 있음
  - 판매자가 라이브(화상채팅)를 켜서 구매자들에게 상품을 보여줌으로써 실물에 가까운 상품을 구매전에 볼 수 있음
- **주요 기능**
  - 게시글 CRUD
  - 댓글 CRUD (계층형, 2 Depth)
  - 게시글 좋아요 (중복 방지 및 좋아요 수 관리)
  - 게시글 조회수 (10분 내 중복 조회 방지)
  - 인기글 기능 (조회수/댓글/좋아요 기반 점수)
  - 게시글/댓글 조회 최적화 (CQRS + Redis)
  - 회원가입/로그인 (gateway + spring security)
  - 게시글 이미지 저장 (게시글 모듈과 분리함)
  - 일반 채팅 (websocket + redis)
  - 화상 채팅 (redis + kafka + openvidu)
- **기술 스택**
  - Spring Boot, MySQL, Redis, Kafka, Docker
  - MSA + 멀티모듈 구조
  - Outbox Pattern + Kafka로 이벤트 전달

---

## 🧠 핵심 기술 요약

### 🧾 ID 생성 전략
- **도구**: Snowflake (common 모듈)
- **이유**: 각 모듈이 독립된 DB 사용 → AUTO_INCREMENT 불가
- **효과**: 전역 고유 ID 보장, 분산 환경에서도 중복 없이 순차적 ID 생성

---

### 🗂 게시글 목록 조회 최적화
- **기존 문제**: OFFSET 기반 페이징 → 후반 페이지로 갈수록 느림
- **해결**
  - 인덱스 설계: `(board_id, article_id DESC)`
  - **Covering Index** 사용: 필요한 컬럼만 SELECT
  - `LIMIT` + `OFFSET` 최소화
- **결과**: 기존 4초 → 최적화 후 0.0x초

---

### 💗 좋아요 기능
- **요구사항**
  - 사용자당 게시글에 1회만 가능
  - 빠르게 좋아요 수 조회
- **해결**
  - 좋아요 수는 별도 테이블로 분리
  - **비관적 락(Pessimistic Lock)** 사용
  - 동시 요청 상황에서도 정확하게 수치 유지

---

### 💬 댓글 기능
- **구현 방식**
  - 계층형 구조 (최대 2 Depth)
  - `parent_id`, `depth` 컬럼 기반 계층 관리
  - 댓글 수 갱신은 **비관적 락 + Update 문** 방식

---

### 👁 조회수 처리
- **요구사항**
  - 유저당 10분에 1회만 조회수 인정
- **기술**
  - Redis 활용
    - `view:{articleId}` : 조회수
    - `viewed:{userId}:{articleId}` : TTL 10분
  - 어뷰징 방지: `setIfAbsent` 사용
  - 주기적 MySQL 백업 (조회수 100 이상일 때만)

---

### 🔥 인기글 서비스
- **기준**
  - 점수 = (좋아요 수 × 3) + (댓글 수 × 2) + (조회수 × 1)
- **처리**
  - Kafka 기반 스트림 수신
  - Redis Sorted Set 저장 (`ZSet`)
  - TTL 설정 → 최근 7일만 유지
- **장점**: 실시간 계산, 배치 불필요, 빠른 응답

---

### 🧃 이벤트 전송 구조 (Transactional Outbox)
- **문제**: Kafka 전송 실패 시 데이터 불일치 발생 가능성
- **해결**: Outbox 테이블에 먼저 저장 → 별도 프로세스로 Kafka 전송
- **효과**: 데이터 무결성 유지, 전송 실패 시 재처리 가능

---

### 🧠 CQRS (조회 최적화)
- **Command/Query 분리**
  - Command: 게시글/댓글/좋아요 서비스
  - Query: 조회 전용 서비스 (Redis 캐시 중심)
- **캐시 전략**
  - 최신 1000건만 Redis에 보관
  - 과거 게시글은 원본 서비스에서 조회
- **조회수는 캐시에 포함 안함** → Redis 직접 접근

---

### ⌨️ 일반 채팅 기능 (WebSocket + Redis 기반)
- **주요 기능**
  - 1:1 실시간 텍스트 채팅
    - 클라이언트 간 WebSocket 연결을 통해 즉시 메시지 송수신 가능
  
  - Redis Pub/Sub 연동
    - 메시지를 Redis 채널에 발행(publish)하고, 구독(subscribe)하는 구조로 다중 서버 간 메시지 전달 및 확장성 확보
  
  - 메시지 영속성 보장
    - 채팅 메시지를 관계형 DB에 저장해 대화 기록 유지
  
  - 캐싱 및 성능 최적화
    - Redis를 활용하여 빠른 메시지 전달과 서버 부하 분산

- **동작 흐름**
  - 사용자가 메시지 전송 → WebSocket 서버로 전달

  - 서버는 메시지를 DB에 저장 후 Redis 채널에 publish

  - Redis를 구독 중인 다른 서버/클라이언트에게 메시지 전달

  - 클라이언트는 실시간으로 메시지를 수신

---

### 🎥 화상채팅 알림 및 세션 관리 (Kafka + Redis + OpenVidu 기반)

- **주요 기능**
  - 화상채팅 세션 생성 및 토큰 발급 (OpenVidu 연동)
    - OpenVidu 서버 API와 연동하여 화상채팅 세션 생성 및 접근 토큰 발급
  
  - 화상채팅 요청 및 응답 처리 (Kafka 이용)
    - 화상채팅 요청, 응답 메시지를 Kafka 토픽으로 비동기 송수신하여 확장성과 비동기 처리를 보장
  
  - Outbox 패턴 적용
    - 데이터베이스에 이벤트 저장 → Kafka로 안전하게 이벤트 발행 → 장애 발생 시 재시도 및 데이터 일관성 확보
  
  - Redis Pub/Sub 알림 전파
    - Kafka에서 수신한 화상채팅 세션 생성 이벤트를 Redis 채널에 발행하여 실시간 알림 구현
  
  - 화상채팅 요청 이력 저장
    - 요청과 세션 정보를 DB에 저장해 상태 추적 및 관리 가능

- **동작 흐름**
  - 클라이언트가 화상채팅 요청 API 호출
  
  - 서버는 요청 이력을 DB에 저장 후 Kafka 토픽에 요청 메시지 발행
  
  - Kafka 리스너가 요청 메시지를 수신해 처리
  
  - 화상채팅 세션 생성 요청 시 OpenVidu API 호출 → 세션과 토큰 발급
  
  - 세션 생성 이벤트를 Outbox 테이블에 저장하고, Outbox 이벤트 릴레이 시스템이 Kafka로 발행
  
  - Kafka에서 이벤트를 수신한 리스너가 Redis Pub/Sub에 이벤트를 발행
  
  - 구독 중인 클라이언트는 Redis 채널을 통해 세션 생성 알림을 실시간으로 수신


---

## 🧰 인프라 구성

| 구성요소 | 설명 |
|----------|------|
| Redis    | 조회수 처리, 캐시, 인기글 ZSet, pub/sub(채팅) |
| Kafka    | 이벤트 기반 통신 (게시글/댓글/좋아요/조회수/화상채팅) |
| MySQL    | 각 서비스 전용 DB, ID 기반 샤딩 |
| Docker   | 모든 인프라 컨테이너화 |

---

## 🔐 Gateway 인증 처리

- **JWT 인증**
  - 로그인 시 토큰 발급
  - Gateway에서 토큰 검증 → 유저 ID 추출
  - 각 서비스에 `X-User-Id` 헤더로 사용자 정보 전달
- **장점**: 인증 집중 관리, 서비스 간 인증 책임 분리

---

## 🧪 테스트 전략

- **RestClient 사용**
  1. 회원가입
  2. 로그인 → JWT 토큰 획득
  3. 게시글 생성
  4. 댓글 생성
  5. 좋아요 클릭
- JWT 헤더는 `"Authorization: Bearer {token}"` 형식

---

## 🔚 정리

- 멀티모듈 + MSA 구조에서 발생하는 **ID 충돌, 조회 병목, 동시성 문제**를 해결하기 위해
  - Snowflake, Redis, Kafka, Outbox, CQRS 등을 활용
- 실시간성과 안정성을 모두 고려한 설계 및 구현 경험 확보
- 실제 기업 수준 아키텍처 설계 및 구현 능력을 갖춘 프로젝트
